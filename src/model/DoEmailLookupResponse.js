/**
 * Textmagic API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';

/**
 * The DoEmailLookupResponse model module.
 * @module model/DoEmailLookupResponse
 * @version 3.0.43879
 */
class DoEmailLookupResponse {
    /**
     * Constructs a new <code>DoEmailLookupResponse</code>.
     * @alias module:model/DoEmailLookupResponse
     * @param address {String} The email address passed to the call.
     * @param status {module:model/DoEmailLookupResponse.StatusEnum} The email is `valid` or `invalid`.
     * @param deliverability {String} The delivery status of the email address is`deliverable`, `undeliverable`. or `unknown`.
     * @param reason {String} The reason why the checked email is invalid/undeliverable.
     * @param risk {module:model/DoEmailLookupResponse.RiskEnum} The risk score of the email is`high`, `medium`, `low` or `null`.
     * @param addressType {module:model/DoEmailLookupResponse.AddressTypeEnum} The email address type (domain) is `free` or `corporate`.
     * @param isDisposableAddress {Boolean} This is `true` if the domain is in the list of disposable email addresses; otherwise, it returns as `false`.
     * @param suggestion {String} Null if nothing is suggested; however, if there is a potential typo in the email address, the closest suggestion is provided.
     * @param emailRole {String} Checks the mailbox part of the email to see whether it matches a specific role type (‘admin’, ‘sales’, ‘webmaster’).
     * @param localPart {String} The local part of the email address.
     * @param domainPart {String} The domain part of the email address.
     * @param exchange {String} Email exchange server domain name (MX record value).
     * @param preference {Number} MX record preference.
     * @param isInWhiteList {Boolean} `true` if the email address exists in the Textmagic whitelist. 
     * @param isInBlackList {Boolean} `true` if the email address exists in the Textmagic blacklist. 
     * @param hasMx {Boolean} `true` if the email address domain has an MX record. 
     * @param hasAa {Boolean} `true` if the email address domain has an A record (IPv4). 
     * @param hasAaaa {Boolean} `true` if the email address domain has an AAAA record (IPv6). 
     */
    constructor(address, status, deliverability, reason, risk, addressType, isDisposableAddress, suggestion, emailRole, localPart, domainPart, exchange, preference, isInWhiteList, isInBlackList, hasMx, hasAa, hasAaaa) { 
        
        DoEmailLookupResponse.initialize(this, address, status, deliverability, reason, risk, addressType, isDisposableAddress, suggestion, emailRole, localPart, domainPart, exchange, preference, isInWhiteList, isInBlackList, hasMx, hasAa, hasAaaa);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj, address, status, deliverability, reason, risk, addressType, isDisposableAddress, suggestion, emailRole, localPart, domainPart, exchange, preference, isInWhiteList, isInBlackList, hasMx, hasAa, hasAaaa) { 
        obj['address'] = address;
        obj['status'] = status;
        obj['deliverability'] = deliverability;
        obj['reason'] = reason;
        obj['risk'] = risk;
        obj['addressType'] = addressType;
        obj['isDisposableAddress'] = isDisposableAddress;
        obj['suggestion'] = suggestion;
        obj['emailRole'] = emailRole;
        obj['localPart'] = localPart;
        obj['domainPart'] = domainPart;
        obj['exchange'] = exchange;
        obj['preference'] = preference;
        obj['isInWhiteList'] = isInWhiteList;
        obj['isInBlackList'] = isInBlackList;
        obj['hasMx'] = hasMx;
        obj['hasAa'] = hasAa;
        obj['hasAaaa'] = hasAaaa;
    }

    /**
     * Constructs a <code>DoEmailLookupResponse</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/DoEmailLookupResponse} obj Optional instance to populate.
     * @return {module:model/DoEmailLookupResponse} The populated <code>DoEmailLookupResponse</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new DoEmailLookupResponse();

            if (data.hasOwnProperty('address')) {
                obj['address'] = ApiClient.convertToType(data['address'], 'String');
            }
            if (data.hasOwnProperty('status')) {
                obj['status'] = ApiClient.convertToType(data['status'], 'String');
            }
            if (data.hasOwnProperty('deliverability')) {
                obj['deliverability'] = ApiClient.convertToType(data['deliverability'], 'String');
            }
            if (data.hasOwnProperty('reason')) {
                obj['reason'] = ApiClient.convertToType(data['reason'], 'String');
            }
            if (data.hasOwnProperty('risk')) {
                obj['risk'] = ApiClient.convertToType(data['risk'], 'String');
            }
            if (data.hasOwnProperty('addressType')) {
                obj['addressType'] = ApiClient.convertToType(data['addressType'], 'String');
            }
            if (data.hasOwnProperty('isDisposableAddress')) {
                obj['isDisposableAddress'] = ApiClient.convertToType(data['isDisposableAddress'], 'Boolean');
            }
            if (data.hasOwnProperty('suggestion')) {
                obj['suggestion'] = ApiClient.convertToType(data['suggestion'], 'String');
            }
            if (data.hasOwnProperty('emailRole')) {
                obj['emailRole'] = ApiClient.convertToType(data['emailRole'], 'String');
            }
            if (data.hasOwnProperty('localPart')) {
                obj['localPart'] = ApiClient.convertToType(data['localPart'], 'String');
            }
            if (data.hasOwnProperty('domainPart')) {
                obj['domainPart'] = ApiClient.convertToType(data['domainPart'], 'String');
            }
            if (data.hasOwnProperty('exchange')) {
                obj['exchange'] = ApiClient.convertToType(data['exchange'], 'String');
            }
            if (data.hasOwnProperty('preference')) {
                obj['preference'] = ApiClient.convertToType(data['preference'], 'Number');
            }
            if (data.hasOwnProperty('isInWhiteList')) {
                obj['isInWhiteList'] = ApiClient.convertToType(data['isInWhiteList'], 'Boolean');
            }
            if (data.hasOwnProperty('isInBlackList')) {
                obj['isInBlackList'] = ApiClient.convertToType(data['isInBlackList'], 'Boolean');
            }
            if (data.hasOwnProperty('hasMx')) {
                obj['hasMx'] = ApiClient.convertToType(data['hasMx'], 'Boolean');
            }
            if (data.hasOwnProperty('hasAa')) {
                obj['hasAa'] = ApiClient.convertToType(data['hasAa'], 'Boolean');
            }
            if (data.hasOwnProperty('hasAaaa')) {
                obj['hasAaaa'] = ApiClient.convertToType(data['hasAaaa'], 'Boolean');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>DoEmailLookupResponse</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>DoEmailLookupResponse</code>.
     */
    static validateJSON(data) {
        // check to make sure all required properties are present in the JSON string
        for (const property of DoEmailLookupResponse.RequiredProperties) {
            if (!data.hasOwnProperty(property)) {
                throw new Error("The required field `" + property + "` is not found in the JSON data: " + JSON.stringify(data));
            }
        }
        // ensure the json data is a string
        if (data['address'] && !(typeof data['address'] === 'string' || data['address'] instanceof String)) {
            throw new Error("Expected the field `address` to be a primitive type in the JSON string but got " + data['address']);
        }
        // ensure the json data is a string
        if (data['status'] && !(typeof data['status'] === 'string' || data['status'] instanceof String)) {
            throw new Error("Expected the field `status` to be a primitive type in the JSON string but got " + data['status']);
        }
        // ensure the json data is a string
        if (data['deliverability'] && !(typeof data['deliverability'] === 'string' || data['deliverability'] instanceof String)) {
            throw new Error("Expected the field `deliverability` to be a primitive type in the JSON string but got " + data['deliverability']);
        }
        // ensure the json data is a string
        if (data['reason'] && !(typeof data['reason'] === 'string' || data['reason'] instanceof String)) {
            throw new Error("Expected the field `reason` to be a primitive type in the JSON string but got " + data['reason']);
        }
        // ensure the json data is a string
        if (data['risk'] && !(typeof data['risk'] === 'string' || data['risk'] instanceof String)) {
            throw new Error("Expected the field `risk` to be a primitive type in the JSON string but got " + data['risk']);
        }
        // ensure the json data is a string
        if (data['addressType'] && !(typeof data['addressType'] === 'string' || data['addressType'] instanceof String)) {
            throw new Error("Expected the field `addressType` to be a primitive type in the JSON string but got " + data['addressType']);
        }
        // ensure the json data is a string
        if (data['suggestion'] && !(typeof data['suggestion'] === 'string' || data['suggestion'] instanceof String)) {
            throw new Error("Expected the field `suggestion` to be a primitive type in the JSON string but got " + data['suggestion']);
        }
        // ensure the json data is a string
        if (data['emailRole'] && !(typeof data['emailRole'] === 'string' || data['emailRole'] instanceof String)) {
            throw new Error("Expected the field `emailRole` to be a primitive type in the JSON string but got " + data['emailRole']);
        }
        // ensure the json data is a string
        if (data['localPart'] && !(typeof data['localPart'] === 'string' || data['localPart'] instanceof String)) {
            throw new Error("Expected the field `localPart` to be a primitive type in the JSON string but got " + data['localPart']);
        }
        // ensure the json data is a string
        if (data['domainPart'] && !(typeof data['domainPart'] === 'string' || data['domainPart'] instanceof String)) {
            throw new Error("Expected the field `domainPart` to be a primitive type in the JSON string but got " + data['domainPart']);
        }
        // ensure the json data is a string
        if (data['exchange'] && !(typeof data['exchange'] === 'string' || data['exchange'] instanceof String)) {
            throw new Error("Expected the field `exchange` to be a primitive type in the JSON string but got " + data['exchange']);
        }

        return true;
    }


}

DoEmailLookupResponse.RequiredProperties = ["address", "status", "deliverability", "reason", "risk", "addressType", "isDisposableAddress", "suggestion", "emailRole", "localPart", "domainPart", "exchange", "preference", "isInWhiteList", "isInBlackList", "hasMx", "hasAa", "hasAaaa"];

/**
 * The email address passed to the call.
 * @member {String} address
 */
DoEmailLookupResponse.prototype['address'] = undefined;

/**
 * The email is `valid` or `invalid`.
 * @member {module:model/DoEmailLookupResponse.StatusEnum} status
 */
DoEmailLookupResponse.prototype['status'] = undefined;

/**
 * The delivery status of the email address is`deliverable`, `undeliverable`. or `unknown`.
 * @member {String} deliverability
 */
DoEmailLookupResponse.prototype['deliverability'] = undefined;

/**
 * The reason why the checked email is invalid/undeliverable.
 * @member {String} reason
 */
DoEmailLookupResponse.prototype['reason'] = undefined;

/**
 * The risk score of the email is`high`, `medium`, `low` or `null`.
 * @member {module:model/DoEmailLookupResponse.RiskEnum} risk
 */
DoEmailLookupResponse.prototype['risk'] = undefined;

/**
 * The email address type (domain) is `free` or `corporate`.
 * @member {module:model/DoEmailLookupResponse.AddressTypeEnum} addressType
 */
DoEmailLookupResponse.prototype['addressType'] = undefined;

/**
 * This is `true` if the domain is in the list of disposable email addresses; otherwise, it returns as `false`.
 * @member {Boolean} isDisposableAddress
 */
DoEmailLookupResponse.prototype['isDisposableAddress'] = undefined;

/**
 * Null if nothing is suggested; however, if there is a potential typo in the email address, the closest suggestion is provided.
 * @member {String} suggestion
 */
DoEmailLookupResponse.prototype['suggestion'] = undefined;

/**
 * Checks the mailbox part of the email to see whether it matches a specific role type (‘admin’, ‘sales’, ‘webmaster’).
 * @member {String} emailRole
 */
DoEmailLookupResponse.prototype['emailRole'] = undefined;

/**
 * The local part of the email address.
 * @member {String} localPart
 */
DoEmailLookupResponse.prototype['localPart'] = undefined;

/**
 * The domain part of the email address.
 * @member {String} domainPart
 */
DoEmailLookupResponse.prototype['domainPart'] = undefined;

/**
 * Email exchange server domain name (MX record value).
 * @member {String} exchange
 */
DoEmailLookupResponse.prototype['exchange'] = undefined;

/**
 * MX record preference.
 * @member {Number} preference
 */
DoEmailLookupResponse.prototype['preference'] = undefined;

/**
 * `true` if the email address exists in the Textmagic whitelist. 
 * @member {Boolean} isInWhiteList
 */
DoEmailLookupResponse.prototype['isInWhiteList'] = undefined;

/**
 * `true` if the email address exists in the Textmagic blacklist. 
 * @member {Boolean} isInBlackList
 */
DoEmailLookupResponse.prototype['isInBlackList'] = undefined;

/**
 * `true` if the email address domain has an MX record. 
 * @member {Boolean} hasMx
 */
DoEmailLookupResponse.prototype['hasMx'] = undefined;

/**
 * `true` if the email address domain has an A record (IPv4). 
 * @member {Boolean} hasAa
 */
DoEmailLookupResponse.prototype['hasAa'] = undefined;

/**
 * `true` if the email address domain has an AAAA record (IPv6). 
 * @member {Boolean} hasAaaa
 */
DoEmailLookupResponse.prototype['hasAaaa'] = undefined;





/**
 * Allowed values for the <code>status</code> property.
 * @enum {String}
 * @readonly
 */
DoEmailLookupResponse['StatusEnum'] = {

    /**
     * value: "valid"
     * @const
     */
    "valid": "valid",

    /**
     * value: "invalid"
     * @const
     */
    "invalid": "invalid"
};


/**
 * Allowed values for the <code>risk</code> property.
 * @enum {String}
 * @readonly
 */
DoEmailLookupResponse['RiskEnum'] = {

    /**
     * value: "high"
     * @const
     */
    "high": "high",

    /**
     * value: "medium"
     * @const
     */
    "medium": "medium",

    /**
     * value: "low"
     * @const
     */
    "low": "low",

    /**
     * value: "unknown"
     * @const
     */
    "unknown": "unknown"
};


/**
 * Allowed values for the <code>addressType</code> property.
 * @enum {String}
 * @readonly
 */
DoEmailLookupResponse['AddressTypeEnum'] = {

    /**
     * value: "corporate"
     * @const
     */
    "corporate": "corporate",

    /**
     * value: "free"
     * @const
     */
    "free": "free"
};



export default DoEmailLookupResponse;

